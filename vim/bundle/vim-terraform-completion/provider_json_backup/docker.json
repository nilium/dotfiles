{"provider_arguments":[{"word":"host","info":"host - (Required) This is the address to the Docker host. If this is\nblank, the DOCKER_HOST environment variable will also be read.\n"},{"word":"cert_path","info":"cert_path - (Optional) Path to a directory with certificate information\nfor connecting to the Docker host via TLS. If this is blank, the\nDOCKER_CERT_PATH will also be checked.\n"},{"word":"ca_material","info":"ca_material, cert_material, key_material, - (Optional) Content of ca.pem, cert.pem, and key.pem files\nfor TLS authentication. Cannot be used together with cert_path.\n"}],"resources":{"container":{"provider":"docker","arguments":[{"word":"name","info":"name - (Required, string) The name of the Docker container.\n","kind":"String(R)"},{"word":"image","info":"image - (Required, string) The ID of the image to back this container.\nThe easiest way to get this value is to use the docker_image resource\nas is shown in the example above.","kind":"String(R)"},{"word":"command","info":"command - (Optional, list of strings) The command to use to start the\ncontainer. For example, to run /usr/bin/myprogram -f baz.conf set the\ncommand to be [\"/usr/bin/myprogram\", \"-f\", \"baz.conf\"].","kind":"List(O)"},{"word":"entrypoint","info":"entrypoint - (Optional, list of strings) The command to use as the\nEntrypoint for the container. The Entrypoint allows you to configure a\ncontainer to run as an executable. For example, to run /usr/bin/myprogram\nwhen starting a container, set the entrypoint to be\n[\"/usr/bin/myprogram\"].","kind":"List(O)"},{"word":"user","info":"user - (Optional, string) User used for run the first process. Format is\nuser or user:group which user and group can be passed literraly or\nby name.","kind":"String(O)"},{"word":"dns","info":"dns - (Optional, set of strings) Set of DNS servers.","kind":"Set(O)"},{"word":"dns_opts","info":"dns_opts - (Optional, set of strings) Set of DNS options used by the DNS provider(s), see resolv.conf documentation for valid list of options.","kind":"Set(O)"},{"word":"dns_search","info":"dns_search - (Optional, set of strings) Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.","kind":"Set(O)"},{"word":"env","info":"env - (Optional, set of strings) Environment variables to set.","kind":"Set(O)"},{"word":"labels","info":"labels - (Optional, map of strings) Key/value pairs to set as labels on the\ncontainer.","kind":"Map(O)"},{"word":"links","info":"links - (Optional, set of strings) Set of links for link based\nconnectivity between containers that are running on the same host.","kind":"Set(O)"},{"word":"hostname","info":"hostname - (Optional, string) Hostname of the container.","kind":"String(O)"},{"word":"domainname","info":"domainname - (Optional, string) Domain name of the container.","kind":"String(O)"},{"word":"restart","info":"restart - (Optional, string) The restart policy for the container. Must be\none of \"no\", \"on-failure\", \"always\", \"unless-stopped\".","kind":"String(O)"},{"word":"max_retry_count","info":"max_retry_count - (Optional, int) The maximum amount of times to an attempt\na restart when restart is set to \"on-failure\"","kind":"Int(O)"},{"word":"must_run","info":"must_run - (Optional, bool) If true, then the Docker container will be\nkept running. If false, then as long as the container exists, Terraform\nassumes it is successful.","kind":"Bool(O)"},{"word":"capabilities","info":"capabilities - (Optional, block) See Capabilities below for details.","kind":"Set(O)(B)","subblock":[{"word":"add","kind":"Set(O)"},{"word":"drop","kind":"Set(O)"}]},{"word":"ports","info":"ports - (Optional, block) See Ports below for details.","kind":"Set(O)(B)","subblock":[{"word":"external","kind":"Int(O)"},{"word":"internal","kind":"Int(R)"},{"word":"ip","kind":"String(O)"},{"word":"protocol","kind":"String(O)"}]},{"word":"host","info":"host - (Optional, block) See Extra Hosts below for\ndetails.","kind":"Set(O)(B)","subblock":[{"word":"host","kind":"String(R)"},{"word":"ip","kind":"String(R)"}]},{"word":"privileged","info":"privileged - (Optional, bool) Run container in privileged mode.","kind":"Bool(O)"},{"word":"publish_all_ports","info":"publish_all_ports - (Optional, bool) Publish all ports of the container.","kind":"Bool(O)"},{"word":"volumes","info":"volumes - (Optional, block) See Volumes below for details.","kind":"Set(O)(B)","subblock":[{"word":"container_path","kind":"String(O)"},{"word":"from_container","kind":"String(O)"},{"word":"host_path","kind":"String(O)"},{"word":"read_only","kind":"Bool(O)"},{"word":"volume_name","kind":"String(O)"}]},{"word":"memory","info":"memory - (Optional, int) The memory limit for the container in MBs.","kind":"Int(O)"},{"word":"memory_swap","info":"memory_swap - (Optional, int) The total memory limit (memory + swap) for the\ncontainer in MBs. This setting may compute to -1 after terraform apply if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.","kind":"Int(O)"},{"word":"cpu_shares","info":"cpu_shares - (Optional, int) CPU shares (relative weight) for the container.","kind":"Int(O)"},{"word":"log_driver","info":"log_driver - (Optional, string) The logging driver to use for the container.\nDefaults to \"json-file\".","kind":"String(O)"},{"word":"log_opts","info":"log_opts - (Optional, map of strings) Key/value pairs to use as options for\nthe logging driver.","kind":"Map(O)"},{"word":"network_mode","info":"network_mode - (Optional, string) Network mode of the container.","kind":"String(O)"},{"word":"networks","info":"networks - (Optional, set of strings) Id of the networks in which the\ncontainer is.","kind":"Set(O)"},{"word":"destroy_grace_seconds","info":"destroy_grace_seconds - (Optional, int) If defined will attempt to stop the container before destroying. Container will be destroyed after n seconds or on successful stop.","kind":"Int(O)"},{"word":"network_alias","kind":"Set(O)"},{"word":"bridge","kind":"String()"},{"word":"gateway","kind":"String()"},{"word":"ip_address","kind":"String()"},{"word":"ip_prefix_length","kind":"Int()"},{"word":"upload","kind":"Set(O)(B)","subblock":[{"word":"content","kind":"String(R)"},{"word":"file","kind":"String(R)"}]}],"attributes":[{"word":"ip_address","info":"ip_address - The IP address of the container as read from its\nNetworkSettings.\n","kind":"String"},{"word":"ip_prefix_length","info":"ip_prefix_length - The IP prefix length of the container as read from its\nNetworkSettings.\n","kind":"Int"},{"word":"gateway","info":"gateway - The network gateway of the container as read from its\nNetworkSettings.\n","kind":"String"},{"word":"bridge","kind":"String"},{"word":"capabilities","kind":"Set(B)","subblock":[{"word":"add","kind":"Set"},{"word":"drop","kind":"Set"},{"word":"id","kind":"String"}]},{"word":"command","kind":"List"},{"word":"cpu_shares","kind":"Int"},{"word":"destroy_grace_seconds","kind":"Int"},{"word":"dns","kind":"Set"},{"word":"dns_opts","kind":"Set"},{"word":"dns_search","kind":"Set"},{"word":"domainname","kind":"String"},{"word":"entrypoint","kind":"List"},{"word":"env","kind":"Set"},{"word":"host","kind":"Set(B)","subblock":[{"word":"host","kind":"String"},{"word":"ip","kind":"String"},{"word":"id","kind":"String"}]},{"word":"hostname","kind":"String"},{"word":"image","kind":"String"},{"word":"labels","kind":"Map"},{"word":"links","kind":"Set"},{"word":"log_driver","kind":"String"},{"word":"log_opts","kind":"Map"},{"word":"max_retry_count","kind":"Int"},{"word":"memory","kind":"Int"},{"word":"memory_swap","kind":"Int"},{"word":"must_run","kind":"Bool"},{"word":"name","kind":"String"},{"word":"network_mode","kind":"String"},{"word":"networks","kind":"Set"},{"word":"ports","kind":"Set(B)","subblock":[{"word":"external","kind":"Int"},{"word":"internal","kind":"Int"},{"word":"ip","kind":"String"},{"word":"protocol","kind":"String"},{"word":"id","kind":"String"}]},{"word":"privileged","kind":"Bool"},{"word":"publish_all_ports","kind":"Bool"},{"word":"restart","kind":"String"},{"word":"upload","kind":"Set(B)","subblock":[{"word":"content","kind":"String"},{"word":"file","kind":"String"},{"word":"id","kind":"String"}]},{"word":"user","kind":"String"},{"word":"volumes","kind":"Set(B)","subblock":[{"word":"container_path","kind":"String"},{"word":"from_container","kind":"String"},{"word":"host_path","kind":"String"},{"word":"read_only","kind":"Bool"},{"word":"volume_name","kind":"String"},{"word":"id","kind":"String"}]},{"word":"network_alias","kind":"Set"},{"word":"id","kind":"String"}]},"image":{"provider":"docker","arguments":[{"word":"name","info":"name - (Required, string) The name of the Docker image, including any tags.\n","kind":"String(R)"},{"word":"keep_locally","info":"keep_locally - (Optional, boolean) If true, then the Docker image won't be\ndeleted on destroy operation. If this is false, it will delete the image from\nthe docker local storage on destroy operation.\n","kind":"Bool(O)"},{"word":"pull_triggers","info":"pull_triggers - (Optional, list of strings) List of values which cause an\nimage pull when changed. This is used to store the image digest from the\nregistry when using the docker_registry_image data source\nto trigger an image update.\n","kind":"Set(O)"},{"word":"latest","kind":"String()"},{"word":"pull_trigger","kind":"String(O)"}],"attributes":[{"word":"keep_locally","kind":"Bool"},{"word":"latest","kind":"String"},{"word":"name","kind":"String"},{"word":"pull_trigger","kind":"String"},{"word":"pull_triggers","kind":"Set"},{"word":"id","kind":"String"}]},"network":{"provider":"docker","arguments":[{"word":"name","info":"name - (Required, string) The name of the Docker network.\n","kind":"String(R)"},{"word":"check_duplicate","info":"check_duplicate - (Optional, boolean) Requests daemon to check for networks\nwith same name.\n","kind":"Bool(O)"},{"word":"driver","info":"driver - (Optional, string) Name of the network driver to use. Defaults to\nbridge driver.\n","kind":"String(O)"},{"word":"options","info":"options - (Optional, map of strings) Network specific options to be used by\nthe drivers.\n","kind":"Map(O)"},{"word":"internal","info":"internal - (Optional, boolean) Restrict external access to the network.\nDefaults to false.\n","kind":"Bool(O)"},{"word":"ipam_driver","info":"ipam_driver - (Optional, string) Driver used by the custom IP scheme of the\nnetwork.\n","kind":"String(O)"},{"word":"id","kind":"String()"},{"word":"ipam_config","kind":"Set(O)(B)","subblock":[{"word":"aux_address","kind":"Map(O)"},{"word":"gateway","kind":"String(O)"},{"word":"ip_range","kind":"String(O)"},{"word":"subnet","kind":"String(O)"}]},{"word":"scope","kind":"String()"}],"attributes":[{"word":"id","info":"id (string)\n","kind":"String"},{"word":"check_duplicate","kind":"Bool"},{"word":"driver","kind":"String"},{"word":"internal","kind":"Bool"},{"word":"ipam_config","kind":"Set(B)","subblock":[{"word":"aux_address","kind":"Map"},{"word":"gateway","kind":"String"},{"word":"ip_range","kind":"String"},{"word":"subnet","kind":"String"},{"word":"id","kind":"String"}]},{"word":"ipam_driver","kind":"String"},{"word":"name","kind":"String"},{"word":"options","kind":"Map"},{"word":"scope","kind":"String"}]},"volume":{"provider":"docker","arguments":[{"word":"name","info":"name - (Optional, string) The name of the Docker volume (generated if not\nprovided).\n","kind":"String(O)"},{"word":"driver","info":"driver - (Optional, string) Driver type for the volume (defaults to local).\n","kind":"String(O)"},{"word":"driver_opts","kind":"Map(O)"},{"word":"mountpoint","kind":"String()"}],"attributes":[{"word":"driver","kind":"String"},{"word":"driver_opts","kind":"Map"},{"word":"mountpoint","kind":"String"},{"word":"name","kind":"String"},{"word":"id","kind":"String"}]}},"datas":{"registry_image":{"provider":"docker","arguments":[{"word":"name","kind":"String(O)"},{"word":"sha256_digest","kind":"String()"}],"attributes":[{"word":"name","kind":"String"},{"word":"sha256_digest","kind":"String"},{"word":"id","kind":"String"}]}},"unknowns":{}}